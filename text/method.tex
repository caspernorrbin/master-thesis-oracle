The methodology is divided into five separate phases:

\begin{enumerate}
    \item Implement the reference design of a memory allocator and verify its functionality to gain understanding and to create a foundation to build upon.
    \item Investigate and identify important aspects for the use of a memory allocator within a garbage collection context by researching the field and inspecting and experimenting on source code.
    \item Modify the reference allocator based on previous research conducted by others.
    \item Further modify the reference allocator for specific garbage collection use cases.
    \item Measure memory fragmentation and allocation speed of the reference allocator and the changes made.
\end{enumerate}

The initial phase involves implementing the original binary buddy allocator as envisioned by Knowlton \cite{buddy}. This is done with the purpose of gaining a more profound understanding of its functionality and establishing a solid foundation for further development. Following the implementation of the base allocator, it is tested using both unit tests and real-world applications. By exporting the allocator as a shared library within a wrapper, it is possible to test real-word programs by overriding the malloc/free operations using the \texttt{LD\_PRELOAD} environment variable.

% The buddy allocator was chosen based on its simplicity and well-established nature, with numerous prior studies available that have adapted it to enhance performance in various scenarios. This extensive existing work opens up various possibilities for modifications, allowing for the continuation and extension of previous efforts.

Once the base allocator is implemented, phase two focuses on delving into the nuances of memory allocation within the context of garbage collection and ZGC. This involves conducting a literature review, as well as examining and experimenting with specific parts of the ZGC source code. This phase is essential to understand the complexities of ZGC and its memory allocation mechanisms, identify potential areas for modification, and determine which alterations has the greatest influence.

% Furthermore, the memory usage patterns produced by both programs and garbage collectors were investigated

After gaining a deeper understanding and implementing the base allocator, the third phase focuses on investigating and integrating modifications to the buddy allocator inspired by prior research. Using the knowledge gained, the most significant changes are applied, sometimes necessitating the implementation of conflicting concepts, splitting the implementation, and allowing for subsequent comparison and evaluation. The emphasis is on leveraging existing work rather than starting from scratch. These adjustments are not exclusively tailored to the context of garbage collection, but rather aimed at improving overall performance or making changes that would produce positive results when employed in garbage collection processes.

Having implemented the modified allocator, the fourth phase focuses on implementing distinct improvements that are relevant to its utilization in a garbage collection environment. These modifications are derived from the insights and knowledge acquired in the preceding phases, rather than based on existing research. These enhancements aim to enhance or introduce features tailored for specific scenarios within ZGC, without affecting performance in other aspects of ZGC or elsewhere.

The implementation process is carried out incrementally, with each minor modification being tested and validated before proceeding to the next step. As the allocator gradually expands, the number of unit tests should also increase. The final version should thus include comprehensive test coverage of the allocator's capabilities. Furthermore, the allocator is tested with preexisting programs after each modification.

The last phase involves evaluating the reference allocator and the modifications implemented. Various important aspects have to be taken into account during the evaluation of the allocator. Factors such as fragmentation, memory usage, and allocation speed are essential metrics that require evaluation and comparison. Certain metrics may be of greater significance in specific scenarios, while other situations may have entirely different demands. A more detailed explanation of the evaluation can be found in Section~\ref{sec:evaluation}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
